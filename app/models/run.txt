class RunTemp < ActiveRecord::Base
  belongs_to :end_step, :class_name => 'Step'
  has_many :actions, :dependent => :destroy
  has_many :vars, :dependent => :destroy
  
  #scope :latest_actions, includes(:actions)
  #scope :latest_actions, includes(:actions)

  def run_from(step)
    # Init
    puts "- run (r#{self.id}) on step (s#{step.id}) #{step.label}"

    # Preparing action
    action = actions.create(:step => step)
    action.save

    # Validate step parameters
    if step.validate_params?
      puts "    - s#{step.id}: exiting: error with step parameters" 
      action.retcode = -1
      action.output = "exiting: error with step parameters"
      action.save
      return
    end

    # Run this step and close the action
    puts "    - s#{step.id}: created action (a#{action.id})"
    action.retcode, action.output = step.run(self, action)
    action.completed_at = Time.now
    action.save
    
    # Loop through next links and follow them, read variables into context
    puts "    - s#{step.id}: step has (#{step.nexts.size}) next steps"
    #var = self.get_vars_hash
    threads = [] 

    step.links.each do |next_link|
      # Evaluate "condition" as ruby code
      # puts "    - s#{step.id}: evaluating condition on link (l#{next_link.id}) to step (s#{next_link.next_id})"
      # execute_next_step = false
      # unless next_link.condition.blank?
      #   begin
      #     condition_return = eval(next_link.condition)
      #     execute_next_step = true if condition_return
      #   rescue Exception => e
      #     puts "    - s#{step.id}: exiting: error with condition on link (l#{next_link.id}) to step (s#{next_link.next_id})" 
      #     action.retcode = -2
      #     action.output = "exiting: condition error on link (l#{next_link.id}) to step (s#{next_link.next_id}): #{e.message}" 
      #     action.save
      #     return
      #   end
      #   puts "    - s#{step.id}: condition returns (#{condition_return})"
      # end
      
      # Evaluate LinkBlocker links
      link_blockers = step.links.blockers
      puts "    - s#{step.id}: step has (#{link_suspends.size}) LinkBlocker links"
      
      blockers_threads = [] 
      threads << Thread.new() {
        # Read this next step
        next_step = Step.includes(:links).find(next_link.next_id)
        puts "    - s#{step.id}: thread executing (s#{next_step.id}) #{next_step.label}"

        # Recurse to this sub-step
        self.run_from(next_step)
        puts "    - s#{step.id}: thread ending for (s#{next_step.id}) #{next_step.label}"
        }
      end

      # Wait for LinkSuspend child process to complete
      puts "- s#{step.id}: waiting for children to finish"
      threads.map { |thread| thread.join}


      # Evaluate all other links
      
      
      # Thread the next step if needed
      if (execute_next_step)
        # Fork for each of the links that passed the condition, create a new thread to run it
        threads << Thread.new() {
          # Read this next step
          next_step = Step.includes(:links).find(next_link.next_id)
          puts "    - s#{step.id}: thread executing (s#{next_step.id}) #{next_step.label}"

          # Recurse to this sub-step
          self.run_from(next_step)
          puts "    - s#{step.id}: thread ending for (s#{next_step.id}) #{next_step.label}"
          }
        end

    end

    # Wait for each child process to complete
    puts "- s#{step.id}: waiting for children to finish"
    threads.map { |thread| thread.join}

    # Finished
    puts "- s#{step.id}: finished"
  end
  
  def run_to(step, active_threads = nil)
    # Init
    ancestors_ids = step.ancestors.map(&:id).join(', ')
    puts "- run (r#{self.id}), step (s#{step.id}) #{step.label}, with (#{step.ancestors.size}) ancestors: #{ancestors_ids}"
    active_threads ||= {}
    
    # Stack steps dependencies recursively
    #puts "    - s#{step.id}: step has (#{step.ancestors.size}) previous steps"
    my_ancestor_threads = []
    step.ancestors.each do |ancestor|
      #puts "    - s#{step.id}: finding ancestor (s#{ancestor.id}) in active_threads containing #{active_threads.size} threads"

      # Let's see if this step is not already running in any thread
      existing_thread_for_this_ancestor = active_threads[ancestor.id]
      
      # If it's not running, let's fork it
      if existing_thread_for_this_ancestor.nil?
        active_threads[ancestor.id] = Thread.new() do
          puts "    - s#{step.id}: threading (s#{ancestor.id}) #{ancestor.label}"
          self.run_to(ancestor, active_threads)
          puts "    - s#{step.id}: thread ending for (s#{ancestor.id}) #{ancestor.label}"
        end

      else
        puts "    - s#{step.id}: attaching existing thread for (s#{ancestor.id})"
      end

      # Stack this thread into my own ancestors threads
      my_ancestor_threads << active_threads[ancestor.id]
      
    end
    
    # Wait for all my ancestors to complete
    puts "    - s#{step.id}: waiting for ancestors threads to complete"
    my_ancestor_threads.map { |thread| thread.join }
    puts "    - s#{step.id}: all ancestors completed"
    
    # Check their return status
    
    # Now we satisfied our dependencies, let's see what we have to do and create a new action
    action = actions.create(:step => step)
    action.save
    puts "    - s#{step.id}: running my own stuff as action (a#{action.id}) as a kind of (#{step.type})"
    
    # Run this step
    action.retcode, action.output = step.run(self, action)

    # Closing action
    action.completed_at = Time.now
    action.save

    # Finished
    puts "    - s#{step.id}: finished"
  end
  
  def set_var(name, value, step = nil, action = nil)
    var = self.vars.find_or_create_by_name(name.to_s, :value => value.to_s, :step => step, :action => action)
    var.value = value.to_s
    var.step = step
    var.action = action
    var.save
    return var
  end
  
  def get_var(name)
    #run_id = run.id unless run.nil?
    record = self.vars.find_by_name(name)
    return record[:value] unless record.nil?
  end
  
  protected
  
  def get_vars_hash
    #run_id = run.id unless run.nil?
    vars = {}
    self.vars.each do |v|
      vars[v.name.to_sym] = v.value
    end
    return vars
  end
  
end